{"updatedAt":"2025-12-05T09:47:23.626Z","createdAt":"2025-12-01T13:34:13.926Z","id":"mB46RTWJHDT4D68n","name":"KTG Step 1 Get Notifications","active":false,"isArchived":false,"nodes":[{"parameters":{"tableId":"ktg_main","dataToSend":"autoMapInputData"},"type":"n8n-nodes-base.supabase","typeVersion":1,"position":[1184,0],"id":"c0ef2aee-e500-4717-a7b8-280ef95bb046","name":"Insert New Records to ktg_main","alwaysOutputData":true,"credentials":{"supabaseApi":{"id":"bAYIwwqmGsUJyjXD","name":"Supabase account"}},"onError":"continueRegularOutput"},{"parameters":{"inputSource":"passthrough"},"type":"n8n-nodes-base.executeWorkflowTrigger","typeVersion":1.1,"position":[-160,0],"id":"dc169491-053a-4549-95bb-5ce69390452a","name":"When Executed by Another Workflow"},{"parameters":{"jsCode":"return [{\n  execution_result: \"Success\",\n  items: $input.all()\n}]"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[1408,0],"id":"3b32391c-74d9-41b0-bd89-91ae4dddc012","name":"Success"},{"parameters":{"jsCode":"// Parse KSC Event Notification → kscEvent JSON\n// Вход: item.json.textPlain (сырое письмо KSC)\n// Выход: item.json = kscEvent\n\nfunction parseKscNotification(raw) {\n  if (!raw) return null;\n\n  const text = String(raw).replace(/\\r\\n/g, '\\n');\n\n  function getField(label) {\n    const re = new RegExp('^' + label + '\\\\s*:\\\\s*(.*)$', 'mi');\n    const m = text.match(re);\n    return m ? m[1].trim() : null;\n  }\n\n  function getDescription() {\n    const marker = 'Description:';\n    const idx = text.indexOf(marker);\n    if (idx === -1) return null;\n    return text.slice(idx + marker.length).trim();\n  }\n\n  return {\n    taskName:     getField('TaskName'),\n    event:        getField('Event'),\n    riseTime:     getField('RiseTime'),\n    severity:     getField('Severity'),\n    computer:     getField('Computer'),\n    domain:       getField('Domain'),\n    hostIp:       getField('HostIP'),\n    connectionIp: getField('ConnectionIP'),\n    product:      getField('Product'),\n    version:      getField('Version'),\n    description:  getDescription(),\n    raw:          text,\n  };\n}\n\nreturn $input.all().map(item => {\n  const body = item.json.textPlain || \"\";\n  const kscEvent = parseKscNotification(body) || {};\n  return { json: kscEvent };\n});"},"id":"28a152ec-8f21-4a1f-a69f-2fb21ae7e476","name":"Parse KSC Notification","type":"n8n-nodes-base.code","typeVersion":2,"position":[64,0]},{"parameters":{"jsCode":"// Normalize field names: camelCase → snake_case (рекурсивно по вложенным объектам)\n\nfunction camelToSnake(str) {\n  return str.replace(/([A-Z])/g, '_$1').toLowerCase();\n}\n\nfunction transformObject(obj) {\n  const out = {};\n  for (const [key, value] of Object.entries(obj)) {\n    const newKey = camelToSnake(key);\n    if (value && typeof value === 'object' && !Array.isArray(value)) {\n      out[newKey] = transformObject(value);\n    } else {\n      out[newKey] = value;\n    }\n  }\n  return out;\n}\n\nreturn $input.all().map(item => {\n  return {\n    json: transformObject(item.json),\n  };\n});"},"id":"d9f987e5-5f34-4986-a378-33579c44876b","name":"Normalize field names (camel→snake)","type":"n8n-nodes-base.code","typeVersion":2,"position":[288,0]},{"parameters":{"jsCode":"const uuid = require('uuid');\n\n// ======================\n// Константы\n// ======================\n\nconst MONTHS_RU = {\n  января: \"01\", февраля: \"02\", марта: \"03\", апреля: \"04\",\n  мая: \"05\", июня: \"06\", июля: \"07\", августа: \"08\",\n  сентября: \"09\", октября: \"10\", ноября: \"12\", декабря: \"12\"\n};\n\n// Исправь, если у тебя правильно: здесь я по памяти, можешь вернуть твой объект MONTHS_RU\n\nconst SEVERITY_MAP = {\n  \"критическое\": \"Critical\",\n  \"высокое\": \"High\",\n  \"среднее\": \"Medium\",\n  \"низкое\": \"Low\",\n  \"информационное\": \"Info\",\n\n  \"крит\": \"Critical\",\n  \"выс\": \"High\",\n  \"сред\": \"Medium\",\n  \"низ\": \"Low\",\n  \"инфо\": \"Info\",\n};\n\n// ======================\n// Хелперы\n// ======================\n\nfunction normalizeSeverity(sev) {\n  if (!sev) return sev;\n  const cleaned = String(sev).trim().toLowerCase();\n  return SEVERITY_MAP[cleaned] || sev;\n}\n\nfunction parseKaspeDate(str) {\n  if (!str) return null;\n\n  const cleaned = str.replace(\" г.\", \"\");\n\n  const match = cleaned.match(\n    /(\\d{1,2})\\s+([А-Яа-я]+)\\s+(\\d{4})\\s+(\\d{1,2}:\\d{2}:\\d{2})\\s+\\(GMT([+-]\\d{1,2}):?(\\d{2})?\\)/\n  );\n\n  if (!match) return null;\n\n  const [, day, monthName, year, time, tzHour, tzMin = \"00\"] = match;\n  const month = MONTHS_RU[monthName.toLowerCase()];\n  if (!month) return null;\n\n  const iso = `${year}-${month}-${day.padStart(2, \"0\")}T${time.padStart(8,\"0\")}${tzHour}:${tzMin}`;\n  console.log(iso);\n  return DateTime.fromISO(iso);\n}\n\n// ======================\n// Основная логика\n// ======================\n\nconst items = $input.all();\n\nfor (const item of items) {\n  const json = item.json;\n\n  // Базовые служебные поля\n  json.status = \"ingested\";\n  json.updated_at = DateTime.now().toISO();\n  json.uuid = uuid.v4();\n\n  // Нормализуем дату/время\n  const parsedDate = parseKaspeDate(json.rise_time);\n  json.rise_time = parsedDate ? parsedDate.toISO() : (json.rise_time || null);\n\n  // Severity\n  json.severity = normalizeSeverity(json.severity);\n}\n\nreturn items;"},"id":"047817d8-dc8d-485e-a902-aef4150831ce","name":"Normalize Base Fields","type":"n8n-nodes-base.code","typeVersion":2,"position":[512,0],"onError":"continueErrorOutput"},{"parameters":{"jsCode":"const CryptoJS = require('crypto-js');\n\n// ======================\n// Маппинг ключей description → канонические поля\n// ======================\n\nconst KEY_MAP = {\n  // Базовые\n  \"event type\": \"event_type\",\n  \"тип события\": \"event_type\",\n\n  \"name\": \"name\",\n  \"имя\": \"name\",\n  \"object\": \"object\",\n  \"объект\": \"object\",\n\n  \"application\": \"application\",\n  \"приложение\": \"application\",\n  \"application path\": \"application_path\",\n  \"путь к приложению\": \"application_path\",\n\n  \"process id\": \"process_id\",\n  \"идентификатор процесса\": \"process_id\",\n  \"process\": \"process_name\",\n  \"process name\": \"process_name\",\n\n  \"user\": \"user\",\n  \"пользователь\": \"user\",\n  \"initiator\": \"user\",\n  \"инициатор\": \"user\",\n\n  \"component\": \"component\",\n  \"компонент\": \"component\",\n\n  \"task name\": \"task_name\",\n  \"задание\": \"task_name\",\n\n  \"object name\": \"object_name\",\n  \"имя объекта\": \"object_name\",\n  \"object type\": \"object_type\",\n  \"тип объекта\": \"object_type\",\n  \"path to object\": \"path_to_object\",\n  \"путь к объекту\": \"path_to_object\",\n\n  \"md5\": \"object_hash_md5\",\n  \"sha256\": \"object_hash_sha256\",\n\n  \"result\": \"result_description\",\n  \"result description\": \"result_description\",\n  \"описание результата\": \"result_description\",\n\n  \"reason\": \"reason\",\n  \"причина\": \"reason\",\n\n  \"precision\": \"precision\",\n  \"точность\": \"precision\",\n\n  \"protocol\": \"protocol\",\n  \"protocol version\": \"protocol_version\",\n\n  \"sender\": \"sender\",\n  \"receiver\": \"receiver\",\n\n  \"attackingcomputermacaddress\": \"attacking_mac\",\n  \"attacking computer mac address\": \"attacking_mac\",\n\n  \"database release date\": \"database_release_date\",\n  \"дата выпуска баз\": \"database_release_date\",\n\n  \"threat level\": \"threat_level\",\n  \"степень угрозы\": \"threat_level\",\n\n  \"type\": \"type\",\n  \"тип\": \"type\",\n\n  \"additional\": \"additional\",\n  \"дополнительно\": \"additional\"\n};\n\n// ======================\n// Хелперы для description\n// ======================\n\nfunction normalizeKey(rawKey) {\n  if (!rawKey) return null;\n  let key = String(rawKey).trim();\n\n  // отрезаем текст в скобках: \"Name (application)\" → \"Name\"\n  key = key.replace(/\\s*\\(.*\\)\\s*$/, \"\");\n\n  const lowered = key.toLowerCase();\n\n  // Иногда KES пишет странно слепленные слова (AttackingComputerMACAddress)\n  const compact = lowered.replace(/\\s+/g, \"\");\n\n  // 1) пробуем по нормальному lower-case\n  if (KEY_MAP[lowered]) return KEY_MAP[lowered];\n\n  // 2) пробуем по \"слепленному\"\n  if (KEY_MAP[compact]) return KEY_MAP[compact];\n\n  // 3) если нет в словаре — вернем generic-версии (snake_case),\n  //   но ТОЛЬКО латиницу, остальное вычистим\n  const slug = lowered\n    .replace(/[^\\sa-z0-9]/g, \" \")\n    .trim()\n    .replace(/\\s+/g, \"_\");\n\n  return slug || null;\n}\n\nfunction addValue(result, key, value) {\n  if (value == null || value === \"\") return;\n\n  value = String(value).trim();\n\n  // Особый кейс для name → массив\n  if (key === \"name\") {\n    if (result.name == null) {\n      result.name = value;\n    } else if (Array.isArray(result.name)) {\n      result.name.push(value);\n    } else {\n      result.name = [result.name, value];\n    }\n    return;\n  }\n\n  // Для остальных: если ключ повторяется — превращаем в массив\n  if (result[key] == null) {\n    result[key] = value;\n  } else if (Array.isArray(result[key])) {\n    result[key].push(value);\n  } else {\n    result[key] = [result[key], value];\n  }\n}\n\nfunction parseDescriptionText(descText) {\n  const result = {};\n  if (!descText) return result;\n  result.raw = descText;\n\n  const text = String(descText).replace(/\\r\\n/g, \"\\n\");\n  const lines = text.split(\"\\n\");\n\n  let currentCanonKey = null;\n\n  for (let rawLine of lines) {\n    if (!rawLine) continue;\n\n    const line = rawLine.trim();\n\n    const colonIndex = line.indexOf(\":\");\n    if (colonIndex > 0) {\n      currentCanonKey = null;\n\n      const rawKey = line.slice(0, colonIndex);\n      const rawValue = line.slice(colonIndex + 1);\n\n      const canonKey = normalizeKey(rawKey);\n      if (!canonKey) continue;\n\n      currentCanonKey = canonKey;\n      addValue(result, canonKey, rawValue);\n    } else {\n      if (currentCanonKey && result[currentCanonKey] != null) {\n        if (Array.isArray(result[currentCanonKey])) {\n          const lastIndex = result[currentCanonKey].length - 1;\n          result[currentCanonKey][lastIndex] =\n            String(result[currentCanonKey][lastIndex]) + \"\\n\" + line;\n        } else {\n          result[currentCanonKey] =\n            String(result[currentCanonKey]) + \"\\n\" + line;\n        }\n      }\n    }\n  }\n\n  return result;\n}\n\n// ======================\n// Хелпер для хэша события\n// ======================\n\nfunction generateEventHash(json) {\n  let riseTimeStr = \"\";\n\n  if (json.rise_time) {\n    if (typeof json.rise_time === \"string\") {\n      riseTimeStr = json.rise_time;\n    } else if (typeof json.rise_time.toString === \"function\") {\n      riseTimeStr = json.rise_time.toString();\n    }\n  }\n\n  const payload = {\n    event:     json.event || \"\",\n    computer:  json.computer || \"\",\n    ip:        json.host_ip || \"\",\n    rise_time: riseTimeStr.split(\".\")[0] || \"\",\n    raw:       json.raw || \"\",\n  };\n\n  return CryptoJS.SHA256(JSON.stringify(payload)).toString();\n}\n\n// ======================\n// Основная логика\n// ======================\n\nconst items = $input.all();\n\nfor (const item of items) {\n  const json = item.json;\n\n  json.description = parseDescriptionText(json.description);\n  json.hash = generateEventHash(json);\n}\n\nreturn items;"},"id":"1bef9afa-1016-4b9b-82b9-d9322a9fb9bf","name":"Parse Description + Hash","type":"n8n-nodes-base.code","typeVersion":2,"position":[736,0],"onError":"continueErrorOutput"},{"parameters":{"jsCode":"const CryptoJS = require('crypto-js');\n\n// --- Хелперы ---\n\nfunction addIfPresent(target, key, value) {\n  if (value === undefined || value === null) return;\n  if (typeof value === 'string' && value.trim() === '') return;\n  target[key] = value;\n}\n\nfunction normalizeUrl(url) {\n  if (!url || typeof url !== 'string') return url;\n  let cleaned = url.split('#')[0].split('?')[0];\n  cleaned = cleaned.replace(/\\/+$/, '');\n  return cleaned;\n}\n\n/**\n * Извлекаем календарную дату (YYYY-MM-DD) из rise_time\n * для учёта в incident_key (уникальность в пределах 24 часов).\n *\n * Ожидается ISO-строка вида \"2025-11-27T11:40:35.000+03:00\".\n * При ошибке парсинга вернёт null.\n */\nfunction extractRiseDate(ev) {\n  const rt = ev.rise_time || ev.riseTime;\n  if (!rt) return null;\n\n  try {\n    const d = new Date(rt);\n    if (Number.isNaN(d.getTime())) return null;\n\n    // Берём UTC-дату (стабильно для всех нод).\n    // Если нужно строго по локальному времени KSC – можно заменить на ручной парсинг.\n    return d.toISOString().slice(0, 10); // 'YYYY-MM-DD'\n  } catch (e) {\n    return null;\n  }\n}\n\n// --- Константы с реальными значениями из KSC ---\n// (всё в lowercase для удобства сравнения)\n//\n// Названия компонентов и событий берём из официальной\n// терминологии Kaspersky Endpoint Security:\n// - Web Threat Protection / Защита от веб-угроз\n// - Network Threat Protection / Защита от сетевых атак / Защита от сетевых угроз\n// - File Threat Protection / Защита от файловых угроз\n// - Event: Visit to a website was prevented / Остановлен переход на сайт\n// - Event: Network attack detected / Обнаружена сетевая атака\n// - Event: Infected or other object detected / Обнаружен зараженный или подозрительный объект\n// - Event: Malicious object detected / Обнаружен вредоносный объект\n\nconst WEB_COMBOS = [\n  // EN: Web Threat Protection + Visit to a website was prevented\n  {\n    task: 'web threat protection',\n    event: 'visit to a website was prevented',\n  },\n  // RU: Защита от веб-угроз + Остановлен переход на сайт\n  {\n    task: 'защита от веб-угроз',\n    event: 'остановлен переход на сайт',\n  },\n  // Возможный официальный вариант формулировки\n  {\n    task: 'защита от веб-угроз',\n    event: 'переход на веб-сайт заблокирован',\n  },\n];\n\nconst NET_ATTACK_COMBOS = [\n  // EN: Network Threat Protection + Network attack detected\n  {\n    task: 'network threat protection',\n    event: 'network attack detected',\n  },\n  // RU: Защита от сетевых атак + Обнаружена сетевая атака\n  {\n    task: 'защита от сетевых атак',\n    event: 'обнаружена сетевая атака',\n  },\n  // В некоторых логах компонент пишется как \"Защита от сетевых угроз\"\n  {\n    task: 'защита от сетевых угроз',\n    event: 'обнаружена сетевая атака',\n  },\n];\n\nconst MALWARE_COMBOS = [\n  // EN: Infected or other object detected (часто в KSC для File / Network объектов)\n  {\n    task: 'network threat protection',\n    event: 'infected or other object detected',\n  },\n  // RU: Обнаружен зараженный или подозрительный объект\n  {\n    task: 'защита от файловых угроз',\n    event: 'обнаружен зараженный или подозрительный объект',\n  },\n  {\n    task: 'file threat protection',\n    event: 'infected or other object detected',\n  },\n\n  // EN: Malicious object detected (типовое событие File Threat Protection)\n  {\n    task: 'file threat protection',\n    event: 'malicious object detected',\n  },\n  {\n    task: 'scheduled kes scan, full - weekly, all devices',\n    event: 'malicious object detected',\n  },\n  // RU: Обнаружен вредоносный объект (локальные базы)\n  {\n    task: 'защита от файловых угроз',\n    event: 'обнаружен вредоносный объект',\n  },\n];\n\n// true, если (task_name,event) входит в список комбинаций\nfunction matchesCombo(taskName, eventType, combos) {\n  const t = (taskName || '').toLowerCase();\n  const e = (eventType || '').toLowerCase();\n  return combos.some((c) => t === c.task && e === c.event);\n}\n\n/**\n * normalizedEvent — объект по твоей JSON-схеме\n * + желательно иметь:\n *   - task_name (из KSC TaskName / Component)\n *   - event (оригинальный текст Event)\n */\nfunction buildIncidentCore(ev) {\n  const core = {};\n\n  const deviceName =\n    ev.device_name || ev.computer || ev.host;\n  const componentRaw =\n    ev.component || ev.module || ev.task_name || '';\n  const eventRaw =\n    ev.event_type || ev.event || '';\n\n  addIfPresent(core, 'device_name', deviceName);\n  addIfPresent(core, 'component', componentRaw);\n  addIfPresent(core, 'event_type', eventRaw);\n\n  const taskName = (ev.task_name || componentRaw || '').toLowerCase();\n  const eventType = (ev.event || ev.event_type || '').toLowerCase();\n\n  // === 1. WEB (Web Threat Protection / Защита от веб-угроз) ===\n  if (matchesCombo(taskName, eventType, WEB_COMBOS)) {\n    // Нормализованный URL\n    const urlNorm =\n      normalizeUrl(ev.url) ||\n      normalizeUrl(ev.path_to_object);\n\n    addIfPresent(core, 'url', urlNorm);\n    addIfPresent(core, 'domain_name', ev.domain_name);\n    addIfPresent(\n      core,\n      'threat_name',\n      ev.threat_name || ev.object_detected || ev.name,\n    );\n    addIfPresent(core, 'threat_type', ev.threat_type);\n    // addIfPresent(core, 'user', ev.user); // если нужно делать инцидент по пользователю\n\n    return core;\n  }\n\n  // === 2. NETWORK ATTACK (Network Threat Protection / Защита от сетевых атак) ===\n  if (matchesCombo(taskName, eventType, NET_ATTACK_COMBOS)) {\n    addIfPresent(\n      core,\n      'threat_name',\n      ev.threat_name || ev.object_detected || ev.name,\n    );\n\n    // Жертва (как в RDP-бруте 93–95: 5.228.4.95:3389)\n    addIfPresent(core, 'target_ip', ev.target_ip);\n    addIfPresent(core, 'target_port', ev.target_port);\n\n    addIfPresent(core, 'protocol', ev.protocol);\n\n    // Если нужно учитывать источник — можно добавить:\n    // addIfPresent(core, 'attacking_ip', ev.attacking_ip);\n\n    return core;\n  }\n\n  // === 3. MALWARE / FILE (Malicious object detected / Infected or other object detected) ===\n  if (matchesCombo(taskName, eventType, MALWARE_COMBOS)) {\n    const objectHash =\n      ev.object_hash_sha256 ||\n      ev.object_hash_md5 ||\n      ev.process_sha256 ||\n      ev.process_md5;\n\n    addIfPresent(core, 'object_hash', objectHash);\n    addIfPresent(\n      core,\n      'threat_name',\n      ev.threat_name || ev.object_detected || ev.name,\n    );\n    addIfPresent(\n      core,\n      'path_to_object',\n      ev.path_to_object || ev.object || ev.object_name,\n    );\n\n    return core;\n  }\n\n  // === 4. Fallback для экзотики / новых типов ===\n  addIfPresent(core, 'name', ev.name);\n  addIfPresent(\n    core,\n    'threat_name',\n    ev.threat_name || ev.object_detected,\n  );\n  addIfPresent(core, 'object_type', ev.object_type);\n\n  return core;\n}\n\n/**\n * incident_key = SHA256( incident_core + rise_date )\n *\n * rise_date берём из ev.rise_time как YYYY-MM-DD (UTC).\n * Это делает ключ уникальным в пределах 24 часов\n * для одной и той же комбинации полей core.\n */\nfunction buildIncidentKey(ev) {\n  const core = buildIncidentCore(ev);\n\n  const riseDate = extractRiseDate(ev);\n  if (riseDate) {\n    // Техническое поле, чтобы явно \"подмешать\" дату в хеш.\n    // В БД можно его не сохранять, но для дебага удобно.\n    core._rise_date = riseDate;\n  }\n\n  const coreJson = JSON.stringify(core);\n  return CryptoJS.SHA256(coreJson).toString();\n}\n\n// --- Основной цикл ноды ---\n\nfor (const item of $input.all()) {\n  const ev = item.json; // или item.json.normalized — как у тебя заведено\n  item.json.incident_key = buildIncidentKey(ev);\n  item.json.call_counter = 0;\n}\n\nreturn $input.all();"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[960,0],"id":"6e163a4a-7466-47dc-afb9-3341bc46394f","name":"Build Incident Core + Daily Incident Key (Kaspersky)"}],"connections":{"When Executed by Another Workflow":{"main":[[{"node":"Parse KSC Notification","type":"main","index":0}]]},"Insert New Records to ktg_main":{"main":[[{"node":"Success","type":"main","index":0}]]},"Parse KSC Notification":{"main":[[{"node":"Normalize field names (camel→snake)","type":"main","index":0}]]},"Normalize field names (camel→snake)":{"main":[[{"node":"Normalize Base Fields","type":"main","index":0}]]},"Normalize Base Fields":{"main":[[{"node":"Parse Description + Hash","type":"main","index":0}]]},"Parse Description + Hash":{"main":[[{"node":"Build Incident Core + Daily Incident Key (Kaspersky)","type":"main","index":0}]]},"Build Incident Core + Daily Incident Key (Kaspersky)":{"main":[[{"node":"Insert New Records to ktg_main","type":"main","index":0}]]}},"settings":{"executionOrder":"v1","callerPolicy":"workflowsFromSameOwner","availableInMCP":false},"staticData":{"node:Email Trigger (IMAP)":{}},"meta":null,"pinData":{},"versionId":"b3e6ca35-9933-407b-9b87-e7c76d2a21ce","triggerCount":1,"shared":[{"updatedAt":"2025-12-01T13:34:13.926Z","createdAt":"2025-12-01T13:34:13.926Z","role":"workflow:owner","workflowId":"mB46RTWJHDT4D68n","projectId":"MqHMA4XA0kClklct"}],"tags":[{"updatedAt":"2025-12-02T08:15:18.330Z","createdAt":"2025-12-02T08:15:18.330Z","id":"LjXBPoStRF00XMDp","name":"kav-ticket-generator"}]}